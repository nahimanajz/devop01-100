## K8s component

- Node
### pod
- smallest unit of k8s
- Usually 1 application per Pod
- Abstraction of a docker container
- Each Pod has it's own IP address



## Main commands for kubectl
kubectl create deployment mongo-depl --image=mongo
kubectl get pod
kubectl describe pod nginx-depl-54bd6589c-r2dbz // kubectl describe pod POD_NAME
kubelet has container run time and the machine run time and the machine itself





every kubernetes worker node needs 
- kubelet
- Kube proxy
- container runtime.
## Master node
Managing processes including 
- scheduling a pod 
- monitoring
- re-schedule/re-start pod?
- joining a new Node?
And this how we interact with cluster?
## Master node uses:
1. API server: it could be UI, kubernetes dashboard, kubernetes api, command line tool like kubelet.
you can consider api server as `GATE WAY, it acts gate keeper for authentication`
 **Request could be:**
  - Creating new pod
  - Deploy new applications
  -  Create new service and more...
2. schedulers:
- It is intelligent to know which specific worker node 
- it takes all worker node and decide where to start that application a node based on available resources:
- scheduler just decide on which Node new Pod should be scheduled
3. Controller manager
When node dies there must be way to reschedule those pods as soon as possible so `controller manger` detects cluster state changes tries to recover that ASAP.
5. etcd: it is cluster brain, it is key value store which stores state changes like pod crashes and new pod creation

## Key takeaway

- Master process are multiple
- Each master node runs its master processes
- API server is load balanced
- ETCD: is shared across masters

## Example of Cluster Set-Up
- 2 masters node which has CPU | RAM | Storage
- 3 Worker nodes which run pods with container inside and ofcourse they need more resources.
## Adding new Node server:
1) Get new bare server
2) Install all the master/ worker node processes
3) Add it to the cluster

## Minikub cluster is composed by:
- Master processes
- Worker processes
## minikube 
 - Minikube always always needs with hypervisor because it must run in virtual environment.
 - Minikube always comes with docker pre-installed 

```
minikube status
minikube
type: Control Plane
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

```
## commands with their use:
- kubectl create deployment nginx-depl --image=nginx 
 * Blueprint for creating pods 
 * Most basic configuration for deployment (name and image to use) 
 * Rest default 
- kubectl get replicaset: 
 * Replicaset is managing the replicas of a pod.
## Layer of Abstraction
 - `Deployment` manages a `ReplicaSet` which manages a `Pod` which is an abstraction of `docker container`
 ## Debugging pods
 - kubectl log 
 - kubectl describe pod  POD_NAME //mongo-depl
 ## Opening interactive terminal
 - kubectl exec -it mongo-depl-85ffbc9879-jzd47 -- bin/bash  
 ## Creating deployment with 
 - kubectl create deployment name image option 1 option 2
 - kubectl apply -f filename.yaml to apply configuration applied in previous message
  with kubectl apply you can create and update deployment configurations 
 
**Specification for deployment** 

``` 
 spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
```
**Specification for the pod**

```
   spec:
      containers:
        - name: nginx
          image: nginx:1.16
          ports:
            - containerPort: 80
```
## YAML Configuration File in kubernetes
- There are 3 parts of configuration file
 1. metadata 
 ```
 metadata: 
    name: nginx-deployment
    labels: 
 ```
 2. specification
  ````
   spec:
      replica: 1
      selector:
      template:
  ```
 3. status (it is automatically generated by K8s)
 status hold desired state and actual state
 etcd holds the current status of any k8s component!
 
 ##  open deployment file  
 - kubectl get pod -o wide
 - kubectl get deployment nginx-deployment -o yaml > nginx-deployment-result.yaml   // show configuration file in detail and save it in file called nginx-deployment-result.yaml

 - kubectl delete -f nginx-deployment.yaml // delete deployment file.

 ## Exercise
 Complete application setup with kubernetes components
 - 2 Deployment / Pod
 - 2 service
 - 1 ConfigMap
 - 1 Secret
 ## More commands
 minikube service mongo-express-service : it assign an external ip address to a service
## Explanations 
 ### Secret Configuration File
 - kind : "secret"
 - metadata/name: a random name
 - type: "opaque" - default for arbitrary key-value pairs
 - data: the actual contents in key-value pairs
 `echo -n 'username' | base64` to create a value you save on username and passoword

# kubernetes Namespaces explained
- what is Namespaces: it is a virtual cluster inside a cluster.
- what are the usecases
- How Namespaces Work and how to use it?
N.B: If you don't define a namespace while creating a component it creates a default namespace
## Listing namespace
- kubectl get configmap -n default : to see namespace which set defaultly
- kubectl get configmap
- kubectl get configmap -o yaml
## creating and configuring namespace
- kubectl create namespace my-namespace
- kubectl apply -f mysql-configmap.yaml -n my-namespace
- namespace can be configured separately in terminal or in configuration yaml file
## to change active namespace:
- We use a tool called `Kubens`
- install it by `brew install kubectx` which comes with kubens
- kubens command highlights active namespace among all the namespaces
- `kubens my-namespace` to set a namespace
## Kubernetes ingres explained
- what is Ingress?
- Ingress YAML Configuration
- When do you need Ingress
- Ingress controller  

request from browser-> ingress->rediret to internal service
# Ingress controller in minikube
- minikube addons enable ingress: this command automatically starts k8s ngix implementation of ingress controller
- kubectl get pod -n kube-system  : command to verify ingres installation
 - kubectl get ns : listing all namespaces

## Environment on which your cluster runs
- Separate server
- Public ip address and open ports
- Entrypoint to cluster
Request comes from browser to `ingress controller` which decides which rule to apply
inorder to access internal `ingress, service and pod`

## Configuring tls

## Helm package manager for kubernetes
- it bundles yaml files
- create your own helm charts with helm 
- push them to helm repository
- download and use existing ones

## K8S STATEFULSET explained
- Statefull applications include all databases like mongodb, mysql, i.e: application that stores data
-  stateless application on the other hand:
1. don't keep record of state
2. treat each request as completely new: new request don't rely on previous request.

- Stateless applications are deployed using deployment
- Stateful applications are deployed using statefulSet

## kubernetes services
- ClusterIp Services
- NodePort Services
- Headless Services
- LoadBalancer Services
## Load balancer services 
- LB service is an extension of NodePort service
- Nodeport service is an extension of cluster service

## Resources: 

code with nana [youtube] (https://www.youtube.com/watch?v=X48VuDVv0do&t=214s)
list of used commands through the [tutorial](minikube status
minikube
type: Control Plane
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured)